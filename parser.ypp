%{
    #include "hw3_output.hpp"
    #include "Utilities.hpp"
%}

%token VOID
%token INT
%token BYTE
%token B
%token BOOL
%token AUTO
%token ID
%token NUM
%token STRING
%token RETURN
%token TRUE
%token FALSE
%token IF
%token BREAK
%token CONTINUE
%token SC
%token COMMA
%token WHILE

%left   ASSIGN
%left   OR
%left   AND
%left   RELOP_EQUAL
%left   RELOP_GLT
%left   BINOP_ADD
%left   BINOP_MUL
%right  NOT
%left   LBRACE
%left   RBRACE
%left   LPAREN
%left   RPAREN
%nonassoc ELSE

%%
//rules
Program:    Funcs
;

Funcs:      /*epsilon*/
            |FuncDecl Funcs
;

FuncDecl:   RetType ID LPAREN Formals RPAREN  /*add func dec to table*/
            LBRACE /*open scope*/ /*add func args as neg entries*/
            Statements /*close scope*/ RBRACE
;

RetType:    Type                            {$$ = new RetTypeClass($1->getType();)}
            |VOID                           {$$ = new RetTypeClass("VOID"); }
;
Formals:	 /*epsilon*/                    {$$ = new FormalsClass();}
			|FormalsList                    {$$ = new FormalsClass($1->getVecArgsType(),$1->getVecArgsID());}
;

FormalsList: FormalDecl                     {$$ = new FormalsListClass(); $$->addNewArg($1->getArgType(),$1->getArgID());}
			|FormalDecl COMMA FormalsList   {$$ = new FormalsListClass($3->getVecArgsType(),$3->getVecArgsID()); $$->addNewArg($1->getArgType(),$1->getArgID());}
;

FormalDecl:	Type ID                         {$$ = new FormalDeclClass($1->getType(),$2->getId()); }
;

Statements:	Statement
			|Statements Statement
;

Statement:	Type ID SC                                           {output::printProductionRule(15);}
			|Type ID ASSIGN Exp SC                               {output::printProductionRule(16);}
			|AUTO ID ASSIGN Exp SC                               {output::printProductionRule(17);}
			|ID ASSIGN Exp SC                                    {output::printProductionRule(18);}
			|Call SC                                             {output::printProductionRule(19);}
			|RETURN SC                                           {output::printProductionRule(20);}
			|RETURN Exp SC                                       {output::printProductionRule(21);}
			|BREAK SC                                            {output::printProductionRule(25);}
			|CONTINUE SC                                         {output::printProductionRule(26);}
            |IF LPAREN Exp RPAREN Statement                      {output::printProductionRule(22);}
			|IF LPAREN Exp RPAREN Statement ELSE Statement       {output::printProductionRule(23);}
			|WHILE LPAREN Exp RPAREN Statement                   {output::printProductionRule(24);}
            |LBRACE Statements RBRACE                            {output::printProductionRule(14);}
;

Call:		ID LPAREN ExpList RPAREN                             {output::printProductionRule(27);}
			|ID LPAREN RPAREN                                    {output::printProductionRule(28);}
;

ExpList:	Exp                                                   {output::printProductionRule(29);}
			|Exp COMMA ExpList                                    {output::printProductionRule(30);}
;

Type:	    INT   {$$ = new TypeClass("INT");}
    		|BYTE {$$ = new TypeClass("BYTE");}
    		|BOOL {$$ = new TypeClass("BOOL");}
;

Exp: 	    ID                      {$$ = new ExpClass(getIdType($1->getId()));}
    		|Call
    		|NUM                    {$$ = new ExpClass("INT",$1->getValue());}
    		|NUM B                  {checkIfBValid($1->getValue());  $$ = new ExpClass("BYTE",$1->getValue());}                                          {output::printProductionRule(39);}
    		|STRING                 {$$ = new ExpClass("STRING");}
    		|TRUE                   {$$ = new ExpClass("BOOL");}
    		|FALSE                  {$$ = new ExpClass("BOOL");}                                            {output::printProductionRule(42);}
    		|NOT Exp                {checkIfBool($2->getType()); $$ = new ExpClass("BOOL");}                                            {output::printProductionRule(43);}
    		|Exp OR Exp             {checkIfBool($1->getType()); checkIfBool($3->getType()); $$ = new ExpClass("BOOL");}                                           {output::printProductionRule(45);}
    		|Exp AND Exp            {checkIfBool($1->getType()); checkIfBool($3->getType()); $$ = new ExpClass("BOOL");}
    		|Exp RELOP_EQUAL Exp    {checkIfNumeric($1->getType()); checkIfNumeric($3->getType()); $$ = new ExpClass("BOOL");}
            |Exp RELOP_GLT Exp      {checkIfNumeric($1->getType()); checkIfNumeric($3->getType()); $$ = new ExpClass("BOOL");}
            |Exp BINOP_ADD Exp      {std::string newType = setRetBinopType($1->getType(),$3->getType()); $$ = new ExpClass(newType);}
            |Exp BINOP_MUL Exp      {std::string newType = setRetBinopType($1->getType(),$3->getType()); $$ = new ExpClass(newType);}
    		|LPAREN Type RPAREN Exp {checkIfNumeric($2->getType()); checkIfNumeric($4->getType()); $$ = new ExpClass($2->getType());}
            |LPAREN Exp RPAREN      {$$ = new ExpClass($2->getType(),$2->getValue());}
;
%%

void yyerror(const char* input) {
    output::errorSyn(yylineno);
    exit(0);
}

int main() {
    return yyparse();
}
