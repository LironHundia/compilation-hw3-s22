%{
    #include "hw3_output.hpp"
    #include "Utilities.hpp"
%}

%token VOID
%token INT
%token BYTE
%token B
%token BOOL
%token AUTO
%token ID
%token NUM
%token STRING
%token RETURN
%token TRUE
%token FALSE
%token IF
%token BREAK
%token CONTINUE
%token SC
%token COMMA
%token WHILE

%left   ASSIGN
%left   OR
%left   AND
%left   RELOP_EQUAL
%left   RELOP_GLT
%left   BINOP_ADD
%left   BINOP_MUL
%right  NOT
%left   LBRACE
%left   RBRACE
%left   LPAREN
%left   RPAREN
%nonassoc ELSE

%%
//rules
Program:    Funcs
;

Funcs:      /*epsilon*/
            |FuncDecl Funcs
;

FuncDecl:   RetType ID LPAREN Formals RPAREN  {addFuncNewEntry($2->getId(),$1->getType(),$4->getVecArgsType());}
            LBRACE {openScope(); addFuncArgsToTable($4->getVecArgsType(),$4->getVecArgsID());} /*add func args as neg entries*/
            Statements {closeScope();}
            RBRACE
;

RetType:    Type                            {$$ = new RetTypeClass($1->getType();)}
            |VOID                           {$$ = new RetTypeClass("VOID"); }
;
Formals:	 /*epsilon*/                    {$$ = new FormalsClass();}
			|FormalsList                    {$$ = new FormalsClass($1->getVecArgsType(),$1->getVecArgsID());}
;

FormalsList: FormalDecl                     {$$ = new FormalsListClass(); $$->addNewArg($1->getArgType(),$1->getArgID());}
			|FormalDecl COMMA FormalsList   {$$ = new FormalsListClass($3->getVecArgsType(),$3->getVecArgsID()); $$->addNewArg($1->getArgType(),$1->getArgID());}
;

FormalDecl:	Type ID                         {$$ = new FormalDeclClass($1->getType(),$2->getId()); }
;

Statements:	Statement
			|Statements Statement
;

Statement:	Type ID SC              {addVarNewEntry($2->getId(),$1->gedType());}
			|Type ID ASSIGN Exp SC  //TODO - need to make sure the type of Exp matches this Type for assignment
			|AUTO ID ASSIGN Exp SC //TODO - ID gets the type of Exp
			|ID ASSIGN Exp SC      //TODO - need to find ID in table and make sure it's and Exp's types match.
			|Call SC
			|RETURN SC
			|RETURN Exp SC
			|BREAK SC
			|CONTINUE SC
            |IF LPAREN Exp RPAREN Statement
			|IF LPAREN Exp RPAREN Statement ELSE Statement
			|WHILE LPAREN Exp RPAREN Statement
            |LBRACE Statements RBRACE
;

Call:		ID LPAREN ExpList RPAREN
			|ID LPAREN RPAREN
;

ExpList:	Exp
			|Exp COMMA ExpList
;

Type:	    INT   {$$ = new TypeClass("INT");}
    		|BYTE {$$ = new TypeClass("BYTE");}
    		|BOOL {$$ = new TypeClass("BOOL");}
;

Exp: 	    ID                      {$$ = new ExpClass(getIdType($1->getId()));}
    		|Call
    		|NUM                    {$$ = new ExpClass("INT",$1->getValue());}
    		|NUM B                  {checkIfBValid($1->getValue());  $$ = new ExpClass("BYTE",$1->getValue());}
    		|STRING                 {$$ = new ExpClass("STRING");}
    		|TRUE                   {$$ = new ExpClass("BOOL");}
    		|FALSE                  {$$ = new ExpClass("BOOL");}
    		|NOT Exp                {checkIfBool($2->getType()); $$ = new ExpClass("BOOL");}
    		|Exp OR Exp             {checkIfBool($1->getType()); checkIfBool($3->getType()); $$ = new ExpClass("BOOL");}
    		|Exp AND Exp            {checkIfBool($1->getType()); checkIfBool($3->getType()); $$ = new ExpClass("BOOL");}
    		|Exp RELOP_EQUAL Exp    {checkIfNumeric($1->getType()); checkIfNumeric($3->getType()); $$ = new ExpClass("BOOL");}
            |Exp RELOP_GLT Exp      {checkIfNumeric($1->getType()); checkIfNumeric($3->getType()); $$ = new ExpClass("BOOL");}
            |Exp BINOP_ADD Exp      {std::string newType = setRetBinopType($1->getType(),$3->getType()); $$ = new ExpClass(newType);}
            |Exp BINOP_MUL Exp      {std::string newType = setRetBinopType($1->getType(),$3->getType()); $$ = new ExpClass(newType);}
    		|LPAREN Type RPAREN Exp {checkIfNumeric($2->getType()); checkIfNumeric($4->getType()); $$ = new ExpClass($2->getType());}
            |LPAREN Exp RPAREN      {$$ = new ExpClass($2->getType(),$2->getValue());}
;
%%

void yyerror(const char* input) {
    output::errorSyn(yylineno);
    exit(0);
}

int main() {
    return yyparse();
}
